{"componentChunkName":"component---src-templates-blog-post-js","path":"/testing-with-mbt/","webpackCompilationHash":"81dda3e49541104d54c7","result":{"data":{"site":{"siteMetadata":{"title":"Six of one","author":"Ben Lowry"}},"markdownRemark":{"id":"b2582ca8-830f-5dca-a994-f45a85c535ba","excerpt":"In my previous post I mentioned how finite state machines (FSMs) could be used to generate test cases. From here, they could be hooked up to a test engine to…","html":"<p>In my <a href=\"../fsm-all-stages\">previous post</a> I mentioned how finite state machines (FSMs) could be used to generate test cases. From here, they could be hooked up to a test engine to give you automated tests, and voila! You’re doing Model Based Testing.</p>\n<p>For this post, consider the FSM below:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ba42f7beca3c5420efd8e16e555e6ceb/331c8/stopwatch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.24469589816125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABJ0AAASdAHeZh94AAABbklEQVQoz22T2Y6CUBBE+f/f8t0nEpWIGyC4L6Ds9uT0TN8Qxk4IV6yurqoGT/7q8/nYUdq2lb7v3d3+N8z9fpfX6yVd10ld14ozjDcmvFwucr1e5Xg8yu12k9PpJFVVOQwDdrud4g6Hg2LAG8azyUaYZZnkeS6r1Uqez6eqKcvSqW+aRs7nsz6bzWaKBfd4PH4Jx3YAzudzWSwW4vu+EqPSbNHMUNQlSeLIrN8bZmeFHZomk4ms12spikKVMWA6nUocx0qCeiuiIFPv/X5LGIbayAUYRZYVRBQZoXaz2ahNFAdBoM9wQy95emZjuVyqDYqMUA6AYqPYs2gYxgBUshCGWM5fLZtC7gCJgDNKUMRvCCEblnttjBR7qNxut3pnMsrJ0FxAyCuVpqlGwiCw7rUZEpInYAhpjqJI9vu9yxVlnLHP0lgSOJQy8B8hNsnNLrJkkyhBGcEzgGZIDMeZDTvC8ac3LpSz0eHWvxUcP4s8mG66n7FXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"State transition diagram of a stopwatch\"\n        title=\"State transition diagram of a stopwatch\"\n        src=\"/static/ba42f7beca3c5420efd8e16e555e6ceb/b9e4f/stopwatch.png\"\n        srcset=\"/static/ba42f7beca3c5420efd8e16e555e6ceb/cf440/stopwatch.png 148w,\n/static/ba42f7beca3c5420efd8e16e555e6ceb/d2d38/stopwatch.png 295w,\n/static/ba42f7beca3c5420efd8e16e555e6ceb/b9e4f/stopwatch.png 590w,\n/static/ba42f7beca3c5420efd8e16e555e6ceb/331c8/stopwatch.png 707w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h1>Generating test plans</h1>\n<p>The FSM is represented by a directed graph. By walking the graph, we can explore the different ways a user might move through an application.\nAt each step, we can assert that we are in the correct state, for example by looking for particular text, or the presence or absence of an element on the page. Then we can take an action, like clicking a button, and assert that we’re in the next expected state.</p>\n<p>“Walking the graph” is how we generate these test plans.\nThere are several options for how to walk the graph. Algorithms like Dijkstra’s Algorithm allow us to find the shortest path from one state (usually the “initial” state) to any other. This doesn’t guarantee that we’ll cover every transition in the FSM, but there are others that do. The <code class=\"language-text\">@xstate/test</code> JS library has built in support for <code class=\"language-text\">getShortestPathPlans</code> and <code class=\"language-text\">getSimplePathPlans</code>.</p>\n<p>In principle, we need to decide what level of “coverage” we want, and then decide what to do from there.</p>\n<h2>Do it yourself</h2>\n<p>It’s trivial (though possibly tedious) to generate test plans yourself. Start with your diagram, and mark each state and transition as you go through. If you just want to hit each</p>\n<p>In principle, we start at the beginning (initial state), take one of the available transitions, end up at another state, then take one of <em>those</em> transitions, until we hit a dead end, or “final” state. That completes one test plan. Then we start again, this time taking a different transition if available. Repeat that process until your coverage measure is met, and those are your test plans.</p>\n<p>[gif? walkthrough of creating plans]</p>\n<p>The above let you generate tests in advance, which could be automated and run later, but it’s also perfectly valid to manually test them — I’ll warn you though; complicated models can result in <em>lots</em> of test plans, so you might be there a while.</p>\n<h2>Online tests</h2>\n<p>Another way to execute tests is to run them “online”. That’s the term used, but really it’s making decisions about which transition to take <em>while you’re executing</em> the tests. Again, several options for how to do this with their own pros and cons — weighted transitions, random walk, higher weight for non-visited paths. One important difference between online and offline tests is that online tests might not be repeatable by re-running them, depending on implementation.</p>\n<h2>An example using <code class=\"language-text\">@xstate/test</code></h2>\n<p>I used XState to generate tests for the FSM above, resulting in 17 generated tests.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> PASS  src/__tests__/with-lap.test.ts\n  stopwatch with lap\n    √ coverage (1 ms)\n    reaches state: &quot;zero&quot; ({&quot;resumeCount&quot;:0,&quot;unlapCount&quot;:0})\n      √ via  (1 ms)\n    reaches state: &quot;running&quot; ({&quot;resumeCount&quot;:0,&quot;unlapCount&quot;:0})\n      √ via PRESS_MAIN_BUTTON (1 ms)\n    reaches state: &quot;stopped&quot; ({&quot;resumeCount&quot;:0,&quot;unlapCount&quot;:0})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON\n    reaches state: &quot;lap&quot; ({&quot;resumeCount&quot;:0,&quot;unlapCount&quot;:0})\n      √ via PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON\n    reaches state: &quot;running&quot; ({&quot;resumeCount&quot;:1,&quot;unlapCount&quot;:0})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON\n    reaches state: &quot;running&quot; ({&quot;resumeCount&quot;:0,&quot;unlapCount&quot;:1})\n      √ via PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON (1 ms)\n    reaches state: &quot;stopped&quot; ({&quot;resumeCount&quot;:1,&quot;unlapCount&quot;:0})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON\n    reaches state: &quot;lap&quot; ({&quot;resumeCount&quot;:1,&quot;unlapCount&quot;:0})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON (1 ms)\n    reaches state: &quot;stopped&quot; ({&quot;resumeCount&quot;:0,&quot;unlapCount&quot;:1})\n      √ via PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON → PRESS_MAIN_BUTTON\n    reaches state: &quot;lap&quot; ({&quot;resumeCount&quot;:0,&quot;unlapCount&quot;:1})\n      √ via PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON\n    reaches state: &quot;zero&quot; ({&quot;resumeCount&quot;:1,&quot;unlapCount&quot;:0})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON\n    reaches state: &quot;running&quot; ({&quot;resumeCount&quot;:1,&quot;unlapCount&quot;:1})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON\n    reaches state: &quot;zero&quot; ({&quot;resumeCount&quot;:0,&quot;unlapCount&quot;:1})\n      √ via PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON → PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON\n    reaches state: &quot;stopped&quot; ({&quot;resumeCount&quot;:1,&quot;unlapCount&quot;:1})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON → PRESS_MAIN_BUTTON\n    reaches state: &quot;lap&quot; ({&quot;resumeCount&quot;:1,&quot;unlapCount&quot;:1})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON (1 ms)\n    reaches state: &quot;zero&quot; ({&quot;resumeCount&quot;:1,&quot;unlapCount&quot;:1})\n      √ via PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON → PRESS_SECOND_BUTTON → PRESS_MAIN_BUTTON → PRESS_SECOND_BUTTON\n\nTest Suites: 1 passed, 1 total\nTests:       17 passed, 17 total</code></pre></div>\n<p>We’ll follow up in more detail in the next post, but to hint at the important bits:</p>\n<ul>\n<li>\n<p>we use <code class=\"language-text\">context</code> to track how many times we’ve been through each loop</p>\n<ul>\n<li><strong>running -> stopped -> running</strong> and</li>\n<li><strong>running -> lap -> running</strong></li>\n</ul>\n</li>\n<li>we define stop conditions where we will traverse each loop at most once, through the <code class=\"language-text\">filter</code> option in <code class=\"language-text\">getShortestPathPlans</code></li>\n</ul>\n<p>We could change the conditions to allow it to go through each loop many times if that was important functionality. In reality, there shouldn’t be any difference in behaviour for a stopwatch.\nEnd-to-end tests can take a while to execute, and we want to balance confidence with execution time, so for this example we’ll only cover that once.</p>\n<p>The next post will go through setting up model-based testing using XState in more detail</p>","frontmatter":{"title":"Level up your testing with Finite State Machines","date":"July 23, 2021","description":"Using finite state machines to model applications allows us to tap into the powerful world of Model Based Testing"},"fields":{"readingTime":{"text":"5 min read"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/testing-with-mbt/","previous":{"fields":{"slug":"/fsm-all-stages/"},"frontmatter":{"title":"Using Finite State Machines to build better software"}},"next":null}}}